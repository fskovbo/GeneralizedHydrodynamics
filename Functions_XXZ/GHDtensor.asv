classdef GHDtensor < handle
    
properties (Access = private)
    
    matrix = [];
    
    % dimensions
    d1 = [] % main rapidity index
    d2 = [] % auxiliary rapidity index
    d3 = [] % main species index
    d4 = [] % auxiliary species index
    d5 = [] % spatial index
end


methods (Access = public)
    % Constructor
    function obj = GHDtensor(varargin)
        % Determine whether input is a matrix of list of dimensions
        if ~isscalar(varargin{1}) % input is matrix
            obj.matrix = varargin{1};
        else
            obj.matrix = zeros(varargin{:});
        end
        
        [d1, d2, d3, d4, d5] = size(obj.matrix);
        obj.d1 = d1;
        obj.d2 = d2;
        obj.d3 = d3;
        obj.d4 = d4;
        obj.d5 = d5;
    end
    
    
    function C = atSpacePoint(obj, x)
        % Gets tensor at certain spatial coordinate x
        mat = obj.matrix(:,:,:,:,x);
        C   = GHDtensor(repmat(mat, 1, 1, 1, 1)); % makes sure all indices are preserved
    end
    
    
    function C = flatten(obj)
        C = reshape(permute(obj.matrix, [1 3 2 4 5]), obj.d1*obj.d3, obj.d2*obj.d4, obj.d5 );
    end
    
    
    function C = unflatten(obj, A)
        C = permute(reshape( A, size(obj.matrix) ), [1 3 2 4 5]);
    end
    
    
    function C = size(obj, dim)
        if nargin == 1
            C = size(double(obj));
        else
            C = size(double(obj),dim);
        end
    end
    
    
    function C = double(obj)
         C = obj.matrix;
    end
    
    
    function C = inv(obj)
        % Solve Uinv*U = I
        I_rapid = eye(obj.d1);
        I_type  = repmat(eye(obj.d3), 1 ,1, 1, obj.d5);
        I_type  = permute(I_type, [3 4 1 2 5]);
        identity= GHDtensor(I_rapid.*I_type);
        
        C       = obj\identity;
    end
    
    
    function C = exp(obj)
        x = double(obj);
        x = exp(x);
        C = GHDtensor(x);
    end
    
    
    function C = log(obj)
        x = double(obj);
        x = log(x);
        C = GHDtensor(x);
    end
    
    
    function C = abs(obj)
        x = double(obj);
        C = GHDtensor(abs(x));
    end
    
    
    function C = transpose(obj)
        % Permutes the two rapidity indices and the two type indices
        % seperately
        x = double(obj);
        x = permute(x,[2 1 4 3 5]);
        C = GHDtensor(x);
    end
    
    
    function obj = setIdentity(obj)
         if obj.d1 ~= obj.d2 && obj.d3 ~= obj.d4
             error('Tensor is not square!')
         end
         
         x = eye( obj.d1*obj.d3, obj.d2*obj.d4 );
         x = unflatten(obj, x);
         x = repmat(x , 1, 1, 1, 1, obj.d5);
         obj.matrix = x;
    end
    
    
    %% Matrix operation overloads
    function B = subsref(obj,S)
        B = subsref(obj.matrix, S);
    end
    
    
    function obj = subsasgn(obj,S,B)
        newMat = subsasgn(obj.matrix,S,B);
        obj.matrix = newMat;
    end
    
    
    function C = plus(A,B)
        a = double(A);
        b = double(B);
        x = plus(a,b);
        
        C = GHDtensor(x);
    end
    
    
    function C = minus(A,B)
        a = double(A);
        b = double(B);
        x = minus(a,b);
        
        C = GHDtensor(x);
    end
    
    
    function C = uplus(obj)
        x = uplus(obj.matrix);
        
        C = GHDtensor(x);
    end
    
    
    function C = uminus(obj)
        x = uminus(obj.matrix);
        
        C = GHDtensor(x);
    end
    
    
    function C = power(A,B)
        % Overloads A.^B
        a = double(A);
        b = double(B);
        x = power(a,b);
        
        C = GHDtensor(x);
    end
    
    
    function C = times(A,B)
        a = double(A);
        b = double(B);
        x = times(a,b); 
        
        C = GHDtensor(x);
    end
    
    
    function C = mtimes(A,B)
        % Overloads A*B
        
        if isa(A,'double') || isa(B,'double')
            a = double(A);
            b = double(B);
            x = mtimes(a,b);
        else
            % Assumes both objects are GHD tensors
        
            a = flatten(A);
            b = flatten(B);

            xsize = size(b);
            xsize(3) = max( size(a,3), size(b,3) );
            x = zeros(xsize);


            if size(a,3) == 1 && size(b,3) == 1 % both homogeneous
                x = mtimes(a,b);
            elseif size(a,3) == 1 % A homogeneous
                for i = 1:size(b,3)
                    x(:,:,i) = mtimes(a,b(:,:,i));
                end
            elseif size(b,3) == 1 % B homogeneous
                for i = 1:size(a,3)
                    x(:,:,i) = mtimes(a(:,:,i),b);
                end
            else % neither homogeneous
                assert( size(a,3) == size(b,3) )
                for i = 1:size(a,3)
                    x(:,:,i) = mtimes(a(:,:,i),b(:,:,i));
                end
            end
            
            % Reverse the flatten()
            % x will have dimensions (N*Nt,N2*Nt,M), where N2 = N or N2 = 1
            % This must be reshaped back to (N,N2,Nt,Nt,M) 
            size_C      = size(B);
            size_C(5)   = max( size(A,5) , size(B,5) );
            size_C( size_C == 0 ) = 1; % fill any missing indices
            size_C      = permute(size_C , [1 3 2 4 5]); % make sure to permute indices, such that size_C = (N,Nt,N2,Nt,M)

            % First split the type and rapidity indices by reshaping, then
            % permute to right positions
            x           = permute(reshape( x, size_C ), [1 3 2 4 5]);
        end
        
        C = GHDtensor(x);
    end
    
    
    function C = rdivide(A,B)
        % Overloads A./B
        a = double(A);
        b = double(B);
        x = rdivide(a,b);
        
        C = GHDtensor(x);
    end
    
    
    function C = mrdivide(A,B)
        % Overloads A/B 
        a = double(A);
        b = double(B);
        x = mrdivide(a,b);
        
        C = GHDtensor(x);
    end
    
    
    function C = mldivide(A,B)
        % Calculates A\B
        % This function assumes both objects are GHD tensors
        a = flatten(A);
        b = flatten(B);
        
        
        xsize = size(b);
        xsize(3) = max( size(a,3), size(b,3) );
        x = zeros(xsize);
        
        
        if size(a,3) == 1 && size(b,3) == 1 % both homogeneous
            x = mldivide(a,b);
        elseif size(a,3) == 1 % A homogeneous
            for i = 1:size(b,3)
                x(:,:,i) = mldivide(a,b(:,:,i));
            end
        elseif size(b,3) == 1 % B homogeneous
            for i = 1:size(a,3)
                x(:,:,i) = mldivide(a(:,:,i),b);
            end
        else % neither homogeneous
            assert( size(a,3) == size(b,3) )
            for i = 1:size(a,3)
                x(:,:,i) = mldivide(a(:,:,i),b(:,:,i));
            end
        end
        
        % Reverse the flatten()
        % x will have dimensions (N*Nt,N2*Nt,M), where N2 = N or N2 = 1
        % This must be reshaped back to (N,N2,Nt,Nt,M) 
        size_C      = size(B);
        size_C(5)   = max( size(A,5) , size(B,5) );
        size_C( size_C == 0 ) = 1; % fill any missing indices
        size_C([2 3])= size_C([2 3]); % make sure to permute indices, such that size_C = (N,Nt,N2,Nt,M)
            
        % First split the type and rapidity indices by reshaping, then
        % permute to right positions
        x           = permute(reshape( x, size_C ), [1 3 2 4 5]);
        
        C           = GHDtensor(x);
    end
    
    
    
end
    
end % end classdef